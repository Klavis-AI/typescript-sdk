/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Klavis from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import urlJoin from "url-join";
import * as errors from "../../../../errors/index.js";

export declare namespace Oauth {
    export interface Options {
        environment?: core.Supplier<environments.KlavisEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey?: core.Supplier<core.BearerToken | undefined>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
        fetcher?: core.FetchFunction;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class Oauth {
    protected readonly _options: Oauth.Options;

    constructor(_options: Oauth.Options = {}) {
        this._options = _options;
    }

    /**
     * Start Slack OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (comma-separated)
     * - user_scope: Optional user-specific scopes to request (comma-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeSlackRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeSlack({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeSlack(
        request: Klavis.OauthAuthorizeSlackRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeSlack(request, requestOptions));
    }

    private async __authorizeSlack(
        request: Klavis.OauthAuthorizeSlackRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const {
            instance_id: instanceId,
            client_id: clientId,
            scope,
            user_scope: userScope,
            redirect_url: redirectUrl,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (userScope != null) {
            _queryParams["user_scope"] = userScope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/slack/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/slack/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start GitHub OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (comma-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeGithubRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeGithub({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeGithub(
        request: Klavis.OauthAuthorizeGithubRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeGithub(request, requestOptions));
    }

    private async __authorizeGithub(
        request: Klavis.OauthAuthorizeGithubRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/github/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/github/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start GitLab OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (space-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeGitlabRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeGitlab({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeGitlab(
        request: Klavis.OauthAuthorizeGitlabRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeGitlab(request, requestOptions));
    }

    private async __authorizeGitlab(
        request: Klavis.OauthAuthorizeGitlabRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/gitlab/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/gitlab/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Supabase OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeSupabaseRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeSupabase({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeSupabase(
        request: Klavis.OauthAuthorizeSupabaseRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeSupabase(request, requestOptions));
    }

    private async __authorizeSupabase(
        request: Klavis.OauthAuthorizeSupabaseRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/supabase/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/supabase/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Notion OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (comma-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeNotionRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeNotion({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeNotion(
        request: Klavis.OauthAuthorizeNotionRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeNotion(request, requestOptions));
    }

    private async __authorizeNotion(
        request: Klavis.OauthAuthorizeNotionRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/notion/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/notion/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Jira OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (comma-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeJiraRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeJira({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeJira(
        request: Klavis.OauthAuthorizeJiraRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeJira(request, requestOptions));
    }

    private async __authorizeJira(
        request: Klavis.OauthAuthorizeJiraRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/jira/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/jira/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Confluence OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (comma-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeConfluenceRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeConfluence({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeConfluence(
        request: Klavis.OauthAuthorizeConfluenceRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeConfluence(request, requestOptions));
    }

    private async __authorizeConfluence(
        request: Klavis.OauthAuthorizeConfluenceRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/confluence/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/confluence/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start WordPress OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (comma-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeWordpressRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeWordpress({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeWordpress(
        request: Klavis.OauthAuthorizeWordpressRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeWordpress(request, requestOptions));
    }

    private async __authorizeWordpress(
        request: Klavis.OauthAuthorizeWordpressRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/wordpress/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/wordpress/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Gmail OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (comma-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeGmailRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeGmail({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeGmail(
        request: Klavis.OauthAuthorizeGmailRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeGmail(request, requestOptions));
    }

    private async __authorizeGmail(
        request: Klavis.OauthAuthorizeGmailRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/gmail/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/gmail/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Google Drive OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (comma-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeGdriveRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeGdrive({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeGdrive(
        request: Klavis.OauthAuthorizeGdriveRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeGdrive(request, requestOptions));
    }

    private async __authorizeGdrive(
        request: Klavis.OauthAuthorizeGdriveRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/gdrive/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/gdrive/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Google Calendar OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (comma-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeGcalendarRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeGcalendar({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeGcalendar(
        request: Klavis.OauthAuthorizeGcalendarRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeGcalendar(request, requestOptions));
    }

    private async __authorizeGcalendar(
        request: Klavis.OauthAuthorizeGcalendarRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/gcalendar/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/gcalendar/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Google Sheets OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (comma-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeGsheetsRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeGsheets({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeGsheets(
        request: Klavis.OauthAuthorizeGsheetsRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeGsheets(request, requestOptions));
    }

    private async __authorizeGsheets(
        request: Klavis.OauthAuthorizeGsheetsRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/gsheets/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/gsheets/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Google Docs OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (comma-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeGdocsRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeGdocs({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeGdocs(
        request: Klavis.OauthAuthorizeGdocsRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeGdocs(request, requestOptions));
    }

    private async __authorizeGdocs(
        request: Klavis.OauthAuthorizeGdocsRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/gdocs/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/gdocs/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Attio OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeAttioRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeAttio({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeAttio(
        request: Klavis.OauthAuthorizeAttioRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeAttio(request, requestOptions));
    }

    private async __authorizeAttio(
        request: Klavis.OauthAuthorizeAttioRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/attio/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/attio/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Salesforce OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (space-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     * - instance_url: Optional Salesforce instance URL for sandbox or custom domains
     *
     * @param {Klavis.OauthAuthorizeSalesforceRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeSalesforce({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeSalesforce(
        request: Klavis.OauthAuthorizeSalesforceRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeSalesforce(request, requestOptions));
    }

    private async __authorizeSalesforce(
        request: Klavis.OauthAuthorizeSalesforceRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const {
            instance_id: instanceId,
            client_id: clientId,
            scope,
            redirect_url: redirectUrl,
            instance_url: instanceUrl,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        if (instanceUrl != null) {
            _queryParams["instance_url"] = instanceUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/salesforce/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/salesforce/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Asana OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (comma-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeAsanaRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeAsana({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeAsana(
        request: Klavis.OauthAuthorizeAsanaRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeAsana(request, requestOptions));
    }

    private async __authorizeAsana(
        request: Klavis.OauthAuthorizeAsanaRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/asana/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/asana/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Linear OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (comma-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeLinearRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeLinear({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeLinear(
        request: Klavis.OauthAuthorizeLinearRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeLinear(request, requestOptions));
    }

    private async __authorizeLinear(
        request: Klavis.OauthAuthorizeLinearRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/linear/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/linear/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Close OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (comma-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeCloseRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeClose({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeClose(
        request: Klavis.OauthAuthorizeCloseRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeClose(request, requestOptions));
    }

    private async __authorizeClose(
        request: Klavis.OauthAuthorizeCloseRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/close/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/close/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start ClickUp OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeClickupRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeClickup({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeClickup(
        request: Klavis.OauthAuthorizeClickupRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeClickup(request, requestOptions));
    }

    private async __authorizeClickup(
        request: Klavis.OauthAuthorizeClickupRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/clickup/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/clickup/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Airtable OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (space-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeAirtableRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeAirtable({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeAirtable(
        request: Klavis.OauthAuthorizeAirtableRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeAirtable(request, requestOptions));
    }

    private async __authorizeAirtable(
        request: Klavis.OauthAuthorizeAirtableRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/airtable/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/airtable/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start HubSpot OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (space-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeHubspotRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeHubspot({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeHubspot(
        request: Klavis.OauthAuthorizeHubspotRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeHubspot(request, requestOptions));
    }

    private async __authorizeHubspot(
        request: Klavis.OauthAuthorizeHubspotRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/hubspot/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/hubspot/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start LinkedIn OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (comma-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeLinkedinRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeLinkedin({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeLinkedin(
        request: Klavis.OauthAuthorizeLinkedinRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeLinkedin(request, requestOptions));
    }

    private async __authorizeLinkedin(
        request: Klavis.OauthAuthorizeLinkedinRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/linkedin/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/linkedin/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Canva OAuth flow with PKCE
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (space-separated, e.g., "design:meta:read profile:read")
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeCanvaRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeCanva({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeCanva(
        request: Klavis.OauthAuthorizeCanvaRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeCanva(request, requestOptions));
    }

    private async __authorizeCanva(
        request: Klavis.OauthAuthorizeCanvaRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/canva/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/canva/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Xero OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (space-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeXeroRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeXero({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeXero(
        request: Klavis.OauthAuthorizeXeroRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeXero(request, requestOptions));
    }

    private async __authorizeXero(
        request: Klavis.OauthAuthorizeXeroRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/xero/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/xero/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Dropbox OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (space-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeDropboxRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeDropbox({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeDropbox(
        request: Klavis.OauthAuthorizeDropboxRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeDropbox(request, requestOptions));
    }

    private async __authorizeDropbox(
        request: Klavis.OauthAuthorizeDropboxRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/dropbox/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/dropbox/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Box OAuth 2.0 flow
     *
     * @param {Klavis.OauthAuthorizeBoxRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeBox({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeBox(
        request: Klavis.OauthAuthorizeBoxRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeBox(request, requestOptions));
    }

    private async __authorizeBox(
        request: Klavis.OauthAuthorizeBoxRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/box/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/box/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start QuickBooks OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - environment: QuickBooks environment to authorize ('sandbox' default)
     * - scope: Optional scopes to request (space-separated). Default is 'com.intuit.quickbooks.accounting'
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeQuickbooksRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeQuickbooks({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeQuickbooks(
        request: Klavis.OauthAuthorizeQuickbooksRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeQuickbooks(request, requestOptions));
    }

    private async __authorizeQuickbooks(
        request: Klavis.OauthAuthorizeQuickbooksRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, environment, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (environment != null) {
            _queryParams["environment"] = environment;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/quickbooks/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/quickbooks/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Zendesk OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (space-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     * - subdomain: Zendesk subdomain for the account being connected
     *
     * @param {Klavis.OauthAuthorizeZendeskRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeZendesk({
     *         instance_id: "instance_id",
     *         subdomain: "subdomain"
     *     })
     */
    public authorizeZendesk(
        request: Klavis.OauthAuthorizeZendeskRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeZendesk(request, requestOptions));
    }

    private async __authorizeZendesk(
        request: Klavis.OauthAuthorizeZendeskRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, subdomain, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        _queryParams["subdomain"] = subdomain;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/zendesk/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/zendesk/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Stripe Connect OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (space-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeStripeRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeStripe({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeStripe(
        request: Klavis.OauthAuthorizeStripeRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeStripe(request, requestOptions));
    }

    private async __authorizeStripe(
        request: Klavis.OauthAuthorizeStripeRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/stripe/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/stripe/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Cal.com OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeCalcomRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeCalcom({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeCalcom(
        request: Klavis.OauthAuthorizeCalcomRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeCalcom(request, requestOptions));
    }

    private async __authorizeCalcom(
        request: Klavis.OauthAuthorizeCalcomRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/calcom/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/calcom/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Vercel OAuth flow using integration pattern
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - client_slug: Vercel integration slug (required for integration-based OAuth)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeVercelRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeVercel({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeVercel(
        request: Klavis.OauthAuthorizeVercelRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeVercel(request, requestOptions));
    }

    private async __authorizeVercel(
        request: Klavis.OauthAuthorizeVercelRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const {
            instance_id: instanceId,
            client_id: clientId,
            client_slug: clientSlug,
            redirect_url: redirectUrl,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (clientSlug != null) {
            _queryParams["client_slug"] = clientSlug;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/vercel/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/vercel/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Pipedrive OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (space-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizePipedriveRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizePipedrive({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizePipedrive(
        request: Klavis.OauthAuthorizePipedriveRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizePipedrive(request, requestOptions));
    }

    private async __authorizePipedrive(
        request: Klavis.OauthAuthorizePipedriveRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/pipedrive/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/pipedrive/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Figma OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (space-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeFigmaRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeFigma({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeFigma(
        request: Klavis.OauthAuthorizeFigmaRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeFigma(request, requestOptions));
    }

    private async __authorizeFigma(
        request: Klavis.OauthAuthorizeFigmaRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/figma/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/figma/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Klavis.OauthAuthorizeKlaviyoRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeKlaviyo({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeKlaviyo(
        request: Klavis.OauthAuthorizeKlaviyoRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeKlaviyo(request, requestOptions));
    }

    private async __authorizeKlaviyo(
        request: Klavis.OauthAuthorizeKlaviyoRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/klaviyo/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/klaviyo/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start PagerDuty OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (comma-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizePagerdutyRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizePagerduty({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizePagerduty(
        request: Klavis.OauthAuthorizePagerdutyRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizePagerduty(request, requestOptions));
    }

    private async __authorizePagerduty(
        request: Klavis.OauthAuthorizePagerdutyRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/pagerduty/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/pagerduty/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start DocuSign OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (comma-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeDocusignRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeDocusign({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeDocusign(
        request: Klavis.OauthAuthorizeDocusignRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeDocusign(request, requestOptions));
    }

    private async __authorizeDocusign(
        request: Klavis.OauthAuthorizeDocusignRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/docusign/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/docusign/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Dialpad OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (space-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     * - code_challenge: PKCE code challenge for enhanced security
     * - code_challenge_method: PKCE code challenge method
     *
     * @param {Klavis.OauthAuthorizeDialpadRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeDialpad({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeDialpad(
        request: Klavis.OauthAuthorizeDialpadRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeDialpad(request, requestOptions));
    }

    private async __authorizeDialpad(
        request: Klavis.OauthAuthorizeDialpadRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const {
            instance_id: instanceId,
            client_id: clientId,
            scope,
            redirect_url: redirectUrl,
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        if (codeChallenge != null) {
            _queryParams["code_challenge"] = codeChallenge;
        }

        if (codeChallengeMethod != null) {
            _queryParams["code_challenge_method"] = codeChallengeMethod;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/dialpad/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/dialpad/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Start Shopify OAuth flow
     *
     * Parameters:
     * - instance_id: Identifier for the instance requesting authorization
     * - shop: Shopify shop domain (e.g., mystore.myshopify.com)
     * - client_id: Optional client ID for white labeling
     * - scope: Optional scopes to request (comma-separated)
     * - redirect_url: Optional URL to redirect to after authorization completes
     *
     * @param {Klavis.OauthAuthorizeShopifyRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeShopify({
     *         instance_id: "instance_id",
     *         shop: "shop"
     *     })
     */
    public authorizeShopify(
        request: Klavis.OauthAuthorizeShopifyRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeShopify(request, requestOptions));
    }

    private async __authorizeShopify(
        request: Klavis.OauthAuthorizeShopifyRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, shop, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        _queryParams["shop"] = shop;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/shopify/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/shopify/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Klavis.OauthAuthorizeOnedriveRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeOnedrive({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeOnedrive(
        request: Klavis.OauthAuthorizeOnedriveRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeOnedrive(request, requestOptions));
    }

    private async __authorizeOnedrive(
        request: Klavis.OauthAuthorizeOnedriveRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/onedrive/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/onedrive/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Klavis.OauthAuthorizeOutlookRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeOutlook({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeOutlook(
        request: Klavis.OauthAuthorizeOutlookRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeOutlook(request, requestOptions));
    }

    private async __authorizeOutlook(
        request: Klavis.OauthAuthorizeOutlookRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/outlook/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/outlook/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Klavis.OauthAuthorizeTeamsRequest} request
     * @param {Oauth.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Klavis.UnprocessableEntityError}
     *
     * @example
     *     await client.oauth.authorizeTeams({
     *         instance_id: "instance_id"
     *     })
     */
    public authorizeTeams(
        request: Klavis.OauthAuthorizeTeamsRequest,
        requestOptions?: Oauth.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__authorizeTeams(request, requestOptions));
    }

    private async __authorizeTeams(
        request: Klavis.OauthAuthorizeTeamsRequest,
        requestOptions?: Oauth.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { instance_id: instanceId, client_id: clientId, scope, redirect_url: redirectUrl } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["instance_id"] = instanceId;
        if (clientId != null) {
            _queryParams["client_id"] = clientId;
        }

        if (scope != null) {
            _queryParams["scope"] = scope;
        }

        if (redirectUrl != null) {
            _queryParams["redirect_url"] = redirectUrl;
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: urlJoin(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.KlavisEnvironment.Default,
                "oauth/teams/authorize",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Klavis.UnprocessableEntityError(
                        _response.error.body as Klavis.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.KlavisError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.KlavisError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.KlavisTimeoutError("Timeout exceeded when calling GET /oauth/teams/authorize.");
            case "unknown":
                throw new errors.KlavisError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        const bearer = await core.Supplier.get(this._options.apiKey);
        if (bearer != null) {
            return `Bearer ${bearer}`;
        }

        return undefined;
    }
}
